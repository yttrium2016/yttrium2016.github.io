<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Linux搭建Reids环境"><meta name="keywords" content="分布式,linux,redis"><meta name="author" content="杨振宇"><meta name="copyright" content="杨振宇"><title>Linux搭建Reids环境 | 杨振宇'Blog</title><link rel="shortcut icon" href="/my-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css?version=1.9.0"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css"><script src="https://cdn.jsdelivr.net/gh/upupming/gitalk@36368e5dffd049e956cdbbd751ff96c28d8255cf/dist/gitalk.min.js"></script><script src="https://cdn.jsdelivr.net/npm/blueimp-md5@2.10.0/js/md5.min.js"></script><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '3.8.0'
} </script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux搭建Reids环境"><span class="toc-number">1.</span> <span class="toc-text">Linux搭建Reids环境</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-number">1.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#下载"><span class="toc-number">1.2.</span> <span class="toc-text">下载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#安装"><span class="toc-number">1.3.</span> <span class="toc-text">安装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启动"><span class="toc-number">1.4.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#开启自启"><span class="toc-number">1.5.</span> <span class="toc-text">开启自启</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#新建启动脚本"><span class="toc-number">1.5.1.</span> <span class="toc-text">新建启动脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#启动脚本"><span class="toc-number">1.5.2.</span> <span class="toc-text">启动脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#授权"><span class="toc-number">1.5.3.</span> <span class="toc-text">授权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#修改redis支持后台启动"><span class="toc-number">1.5.4.</span> <span class="toc-text">修改redis支持后台启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#启动-1"><span class="toc-number">1.5.5.</span> <span class="toc-text">启动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#开机自启"><span class="toc-number">1.5.6.</span> <span class="toc-text">开机自启</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#测试运行"><span class="toc-number">1.6.</span> <span class="toc-text">测试运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置文件"><span class="toc-number">1.7.</span> <span class="toc-text">配置文件</span></a></li></ol></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="https://raw.githubusercontent.com/yttrium2016/img/master/20190222151701.png"></div><div class="author-info__name text-center">杨振宇</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">23</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">30</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div></div></div><div id="content-outer"><div class="no-bg" id="top-container"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">杨振宇'Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">博客</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title">Linux搭建Reids环境</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2020-10-25</time><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/后台/">后台</a><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">7.2k</span><span class="post-meta__separator">|</span><span>阅读时长: 37 分钟</span></div></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="Linux搭建Reids环境"><a href="#Linux搭建Reids环境" class="headerlink" title="Linux搭建Reids环境"></a>Linux搭建Reids环境</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Redis（Remote Dictionary Server )，即远程字典服务，是一个开源的使用ANSI <a href="https://baike.baidu.com/item/C语言" target="_blank" rel="noopener">C语言</a>编写、支持网络、可基于内存亦可持久化的日志型、Key-Value<a href="https://baike.baidu.com/item/数据库/103728" target="_blank" rel="noopener">数据库</a>，并提供多种语言的API。从2010年3月15日起，Redis的开发工作由VMware主持。从2013年5月开始，Redis的开发由<a href="https://baike.baidu.com/item/Pivotal" target="_blank" rel="noopener">Pivotal</a>赞助。</p>
<p><a href="https://redis.io/" target="_blank" rel="noopener">官方网址</a> <a href="https://redis.io/download" target="_blank" rel="noopener">下载地址</a></p>
<h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>使用ssh连接上linux服务器</p>
<p>在指定目录下载 Redis<a href="https://redis.io/download" target="_blank" rel="noopener">下载地址</a></p>
<p>我在linux的/opt目录下载安装的</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /opt</span><br><span class="line">mkdir redis</span><br><span class="line"><span class="built_in">cd</span> redis</span><br><span class="line">wget https://download.redis.io/releases/redis-6.2.0.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -xzvf redis-6.2.0.tar.gz</span><br></pre></td></tr></table></figure>
<p><img src="http://img.yzy.ink/image-20210225102905681.png" alt="image-20210225102905681"></p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入redis-6.2.0目录</span></span><br><span class="line"><span class="built_in">cd</span> redis-6.2.0</span><br><span class="line"><span class="comment"># 进行make</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 如果没有gcc 或者其他依赖自己安装</span></span><br><span class="line">yum install xxx -y</span><br></pre></td></tr></table></figure>
<p><img src="http://img.yzy.ink/image-20210225103627015.png" alt="image-20210225103627015"></p>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><p>进入 根目录的src目录</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> src</span><br><span class="line"><span class="comment"># 显示可执行文件</span></span><br><span class="line">ls -F|grep <span class="string">"*"</span></span><br><span class="line"></span><br><span class="line">[root@localhost src]<span class="comment"># ls -F|grep "*"</span></span><br><span class="line">mkreleasehdr.sh*</span><br><span class="line">redis-benchmark* <span class="comment">#性能测试工具</span></span><br><span class="line">redis-check-aof* <span class="comment">#日志文件检测工(比如断电造成日志损坏,可以检测并修复)</span></span><br><span class="line">redis-check-rdb* <span class="comment">#快照文件检测工具,效果类上</span></span><br><span class="line">redis-cli*       <span class="comment">#客户端</span></span><br><span class="line">redis-sentinel* </span><br><span class="line">redis-server*    <span class="comment">#服务端</span></span><br><span class="line">redis-trib.rb*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">./redis-server</span><br><span class="line"></span><br><span class="line">[root@localhost src]<span class="comment"># ./redis-server </span></span><br><span class="line">31406:C 24 Feb 2021 21:43:49.408 <span class="comment"># oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span></span><br><span class="line">31406:C 24 Feb 2021 21:43:49.408 <span class="comment"># Redis version=6.2.0, bits=64, commit=00000000, modified=0, pid=31406, just started</span></span><br><span class="line">31406:C 24 Feb 2021 21:43:49.408 <span class="comment"># Warning: no config file specified, using the default config. In order to specify a config file use ./redis-server /path/to/redis.conf</span></span><br><span class="line">31406:M 24 Feb 2021 21:43:49.408 * Increased maximum number of open files to 10032 (it was originally <span class="built_in">set</span> to 1024).</span><br><span class="line">31406:M 24 Feb 2021 21:43:49.408 * monotonic clock: POSIX clock_gettime</span><br><span class="line">                _._                                                  </span><br><span class="line">           _.-``__ <span class="string">''</span>-._                                             </span><br><span class="line">      _.-``    `.  `_.  <span class="string">''</span>-._           Redis 6.2.0 (00000000/0) 64 bit</span><br><span class="line">  .-`` .-```.  ```\/    _.,_ <span class="string">''</span>-._                                   </span><br><span class="line"> (    <span class="string">'      ,       .-`  | `,    )     Running in standalone mode</span></span><br><span class="line"><span class="string"> |`-._`-...-` __...-.``-._|'</span>` _.-<span class="string">'|     Port: 6379</span></span><br><span class="line"><span class="string"> |    `-._   `._    /     _.-'</span>    |     PID: 31406</span><br><span class="line">  `-._    `-._  `-./  _.-<span class="string">'    _.-'</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">'    _.-'</span>_.-<span class="string">'|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-'</span>_.-<span class="string">'    |           http://redis.io        </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-'</span>_.-<span class="string">'    _.-'</span>                                   </span><br><span class="line"> |`-._`-._    `-.__.-<span class="string">'    _.-'</span>_.-<span class="string">'|                                  </span></span><br><span class="line"><span class="string"> |    `-._`-._        _.-'</span>_.-<span class="string">'    |                                  </span></span><br><span class="line"><span class="string">  `-._    `-._`-.__.-'</span>_.-<span class="string">'    _.-'</span>                                   </span><br><span class="line">      `-._    `-.__.-<span class="string">'    _.-'</span>                                       </span><br><span class="line">          `-._        _.-<span class="string">'                                           </span></span><br><span class="line"><span class="string">              `-.__.-'</span>                                               </span><br><span class="line"></span><br><span class="line">31406:M 24 Feb 2021 21:43:49.409 <span class="comment"># WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</span></span><br><span class="line">31406:M 24 Feb 2021 21:43:49.409 <span class="comment"># Server initialized</span></span><br><span class="line">31406:M 24 Feb 2021 21:43:49.409 <span class="comment"># WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add 'vm.overcommit_memory = 1' to /etc/sysctl.conf and then reboot or run the command 'sysctl vm.overcommit_memory=1' for this to take effect.</span></span><br><span class="line">31406:M 24 Feb 2021 21:43:49.409 * Loading RDB produced by version 6.2.0</span><br><span class="line">31406:M 24 Feb 2021 21:43:49.409 * RDB age 42 seconds</span><br><span class="line">31406:M 24 Feb 2021 21:43:49.409 * RDB memory usage when created 0.77 Mb</span><br><span class="line">31406:M 24 Feb 2021 21:43:49.409 * DB loaded from disk: 0.000 seconds</span><br><span class="line">31406:M 24 Feb 2021 21:43:49.409 * Ready to accept connections</span><br></pre></td></tr></table></figure>
<h3 id="开启自启"><a href="#开启自启" class="headerlink" title="开启自启"></a>开启自启</h3><h4 id="新建启动脚本"><a href="#新建启动脚本" class="headerlink" title="新建启动脚本"></a>新建启动脚本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/init.d/redis</span><br></pre></td></tr></table></figure>
<h4 id="启动脚本"><a href="#启动脚本" class="headerlink" title="启动脚本"></a>启动脚本</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redis文件</span></span><br><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">#chkconfig:   2345 90 10</span></span><br><span class="line"><span class="comment">#description:  Redis is a persistent key-value database</span></span><br><span class="line">PATH=/opt/redis/redis-6.2.0/src:/sbin:/usr/bin:/bin</span><br><span class="line"></span><br><span class="line">REDISPORT=6379</span><br><span class="line">EXEC=/opt/redis/redis-6.2.0/src/redis-server</span><br><span class="line">REDIS_CLI=/opt/redis/redis-6.2.0/src/redis-cli</span><br><span class="line">PIDFILE=/var/run/redis_6379.pid</span><br><span class="line"><span class="comment"># 默认配置</span></span><br><span class="line">CONF=/opt/redis/redis-6.2.0/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">"<span class="variable">$1</span>"</span> <span class="keyword">in</span>  </span><br><span class="line">    start)  </span><br><span class="line">        <span class="keyword">if</span> [ -f <span class="variable">$PIDFILE</span> ]  </span><br><span class="line">        <span class="keyword">then</span>  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$PIDFILE</span> exists, process is already running or crashed"</span>  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Starting Redis server..."</span>  </span><br><span class="line">                <span class="variable">$EXEC</span> <span class="variable">$CONF</span>  </span><br><span class="line">        <span class="keyword">fi</span>  </span><br><span class="line">        <span class="keyword">if</span> [ <span class="string">"$?"</span>=<span class="string">"0"</span> ]   </span><br><span class="line">        <span class="keyword">then</span>  </span><br><span class="line">              <span class="built_in">echo</span> <span class="string">"Redis is running..."</span>  </span><br><span class="line">        <span class="keyword">fi</span>  </span><br><span class="line">        ;;  </span><br><span class="line">    stop)  </span><br><span class="line">        <span class="keyword">if</span> [ ! -f <span class="variable">$PIDFILE</span> ]  </span><br><span class="line">        <span class="keyword">then</span>  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"<span class="variable">$PIDFILE</span> does not exist, process is not running"</span>  </span><br><span class="line">        <span class="keyword">else</span>  </span><br><span class="line">                PID=$(cat <span class="variable">$PIDFILE</span>)  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Stopping ..."</span>  </span><br><span class="line">                <span class="variable">$REDIS_CLI</span> -p <span class="variable">$REDISPORT</span> SHUTDOWN  </span><br><span class="line">                <span class="keyword">while</span> [ -x <span class="variable">$&#123;PIDFILE&#125;</span> ]  </span><br><span class="line">               <span class="keyword">do</span>  </span><br><span class="line">                    <span class="built_in">echo</span> <span class="string">"Waiting for Redis to shutdown ..."</span>  </span><br><span class="line">                    sleep 1  </span><br><span class="line">                <span class="keyword">done</span>  </span><br><span class="line">                <span class="built_in">echo</span> <span class="string">"Redis stopped"</span>  </span><br><span class="line">        <span class="keyword">fi</span>  </span><br><span class="line">        ;;  </span><br><span class="line">   restart|force-reload)  </span><br><span class="line">        <span class="variable">$&#123;0&#125;</span> stop  </span><br><span class="line">        <span class="variable">$&#123;0&#125;</span> start  </span><br><span class="line">        ;;  </span><br><span class="line">  *)  </span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"Usage: /etc/init.d/redis &#123;start|stop|restart|force-reload&#125;"</span> &gt;&amp;2  </span><br><span class="line">        <span class="built_in">exit</span> 1  </span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<h4 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 755 /etc/init.d/redis</span><br></pre></td></tr></table></figure>
<h4 id="修改redis支持后台启动"><a href="#修改redis支持后台启动" class="headerlink" title="修改redis支持后台启动"></a>修改redis支持后台启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /opt/redis/redis-6.2.0/redis.conf</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定位到设置</span></span><br><span class="line">/daemonize</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改为yes</span></span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure>
<p><img src="http://img.yzy.ink/image-20210225105836964.png" alt="image-20210225105836964"></p>
<h4 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/init.d/redis start</span><br></pre></td></tr></table></figure>
<p><img src="http://img.yzy.ink/image-20210225110558764.png" alt="image-20210225110558764"></p>
<h4 id="开机自启"><a href="#开机自启" class="headerlink" title="开机自启"></a>开机自启</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chkconfig --add /etc/init.d/redis</span><br><span class="line">chkconfig redis on</span><br></pre></td></tr></table></figure>
<h3 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 连接</span></span><br><span class="line">./redis-cli [-h localhost -p 6379 ]</span><br></pre></td></tr></table></figure>
<p><img src="http://img.yzy.ink/image-20210225111148351.png" alt="image-20210225111148351"></p>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># redis 配置文件示例</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当你需要为某个配置项指定内存大小的时候，必须要带上单位，</span></span><br><span class="line"><span class="comment"># 通常的格式就是 1k 5gb 4m 等酱紫：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1k  =&gt; 1000 bytes</span></span><br><span class="line"><span class="comment"># 1kb =&gt; 1024 bytes</span></span><br><span class="line"><span class="comment"># 1m  =&gt; 1000000 bytes</span></span><br><span class="line"><span class="comment"># 1mb =&gt; 1024*1024 bytes</span></span><br><span class="line"><span class="comment"># 1g  =&gt; 1000000000 bytes</span></span><br><span class="line"><span class="comment"># 1gb =&gt; 1024*1024*1024 bytes</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 单位是不区分大小写的，你写 1K 5GB 4M 也行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## INCLUDES ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 假如说你有一个可用于所有的 redis server 的标准配置模板，</span></span><br><span class="line"><span class="comment"># 但针对某些 server 又需要一些个性化的设置，</span></span><br><span class="line"><span class="comment"># 你可以使用 include 来包含一些其他的配置文件，这对你来说是非常有用的。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 但是要注意哦，include 是不能被 config rewrite 命令改写的</span></span><br><span class="line"><span class="comment"># 由于 redis 总是以最后的加工线作为一个配置指令值，所以你最好是把 include 放在这个文件的最前面，</span></span><br><span class="line"><span class="comment"># 以避免在运行时覆盖配置的改变，相反，你就把它放在后面（外国人真啰嗦）。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># include /path/to/local.conf</span></span><br><span class="line"><span class="comment"># include /path/to/other.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################ 常用 #####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下 redis 不是作为守护进程运行的，如果你想让它在后台运行，你就把它改成 yes。</span></span><br><span class="line"><span class="comment"># 当redis作为守护进程运行的时候，它会写一个 pid 到 /var/run/redis.pid 文件里面。</span></span><br><span class="line">daemonize no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 当redis作为守护进程运行的时候，它会把 pid 默认写到 /var/run/redis.pid 文件里面，</span></span><br><span class="line"><span class="comment"># 但是你可以在这里自己制定它的文件位置。</span></span><br><span class="line">pidfile /var/run/redis.pid</span><br><span class="line"></span><br><span class="line"><span class="comment"># 监听端口号，默认为 6379，如果你设为 0 ，redis 将不在 socket 上监听任何客户端连接。</span></span><br><span class="line">port 6379</span><br><span class="line"></span><br><span class="line"><span class="comment"># TCP 监听的最大容纳数量</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 在高并发的环境下，你需要把这个值调高以避免客户端连接缓慢的问题。</span></span><br><span class="line"><span class="comment"># Linux 内核会一声不响的把这个值缩小成 /proc/sys/net/core/somaxconn 对应的值，</span></span><br><span class="line"><span class="comment"># 所以你要修改这两个值才能达到你的预期。</span></span><br><span class="line">tcp-backlog 511</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，redis 在 server 上所有有效的网络接口上监听客户端连接。</span></span><br><span class="line"><span class="comment"># 你如果只想让它在一个网络接口上监听，那你就绑定一个IP或者多个IP。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 示例，多个IP用空格隔开:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># bind 192.168.1.100 10.0.0.1</span></span><br><span class="line"><span class="comment"># bind 127.0.0.1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定 unix socket 的路径。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># unixsocket /tmp/redis.sock</span></span><br><span class="line"><span class="comment"># unixsocketperm 755</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定在一个 client 空闲多少秒之后关闭连接（0 就是不管它）</span></span><br><span class="line">timeout 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># tcp 心跳包。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果设置为非零，则在与客户端缺乏通讯的时候使用 SO_KEEPALIVE 发送 tcp acks 给客户端。</span></span><br><span class="line"><span class="comment"># 这个之所有有用，主要由两个原因：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) 防止死的 peers</span></span><br><span class="line"><span class="comment"># 2) Take the connection alive from the point of view of network</span></span><br><span class="line"><span class="comment">#    equipment in the middle.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># On Linux, the specified value (in seconds) is the period used to send ACKs.</span></span><br><span class="line"><span class="comment"># Note that to close the connection the double of the time is needed.</span></span><br><span class="line"><span class="comment"># On other kernels the period depends on the kernel configuration.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A reasonable value for this option is 60 seconds.</span></span><br><span class="line"><span class="comment"># 推荐一个合理的值就是60秒</span></span><br><span class="line">tcp-keepalive 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义日志级别。</span></span><br><span class="line"><span class="comment"># 可以是下面的这些值：</span></span><br><span class="line"><span class="comment"># debug (适用于开发或测试阶段)</span></span><br><span class="line"><span class="comment"># verbose (many rarely useful info, but not a mess like the debug level)</span></span><br><span class="line"><span class="comment"># notice (适用于生产环境)</span></span><br><span class="line"><span class="comment"># warning (仅仅一些重要的消息被记录)</span></span><br><span class="line">loglevel notice</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定日志文件的位置</span></span><br><span class="line">logfile <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 要想把日志记录到系统日志，就把它改成 yes，</span></span><br><span class="line"><span class="comment"># 也可以可选择性的更新其他的syslog 参数以达到你的要求</span></span><br><span class="line"><span class="comment"># syslog-enabled no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 syslog 的 identity。</span></span><br><span class="line"><span class="comment"># syslog-ident redis</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 syslog 的 facility，必须是 USER 或者是 LOCAL0-LOCAL7 之间的值。</span></span><br><span class="line"><span class="comment"># syslog-facility local0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置数据库的数目。</span></span><br><span class="line"><span class="comment"># 默认数据库是 DB 0，你可以在每个连接上使用 select &lt;dbid&gt; 命令选择一个不同的数据库，</span></span><br><span class="line"><span class="comment"># 但是 dbid 必须是一个介于 0 到 databasees - 1 之间的值</span></span><br><span class="line">databases 16</span><br><span class="line"></span><br><span class="line"><span class="comment">################################ 快照 ################################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 存 DB 到磁盘：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   格式：save &lt;间隔时间（秒）&gt; &lt;写入次数&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   根据给定的时间间隔和写入次数将数据保存到磁盘</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   下面的例子的意思是：</span></span><br><span class="line"><span class="comment">#   900 秒内如果至少有 1 个 key 的值变化，则保存</span></span><br><span class="line"><span class="comment">#   300 秒内如果至少有 10 个 key 的值变化，则保存</span></span><br><span class="line"><span class="comment">#   60 秒内如果至少有 10000 个 key 的值变化，则保存</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   注意：你可以注释掉所有的 save 行来停用保存功能。</span></span><br><span class="line"><span class="comment">#   也可以直接一个空字符串来实现停用：</span></span><br><span class="line"><span class="comment">#   save ""</span></span><br><span class="line"></span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认情况下，如果 redis 最后一次的后台保存失败，redis 将停止接受写操作，</span></span><br><span class="line"><span class="comment"># 这样以一种强硬的方式让用户知道数据不能正确的持久化到磁盘，</span></span><br><span class="line"><span class="comment"># 否则就会没人注意到灾难的发生。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果后台保存进程重新启动工作了，redis 也将自动的允许写操作。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 然而你要是安装了靠谱的监控，你可能不希望 redis 这样做，那你就改成 no 好了。</span></span><br><span class="line">stop-writes-on-bgsave-error yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否在 dump .rdb 数据库的时候使用 LZF 压缩字符串</span></span><br><span class="line"><span class="comment"># 默认都设为 yes</span></span><br><span class="line"><span class="comment"># 如果你希望保存子进程节省点 cpu ，你就设置它为 no ，</span></span><br><span class="line"><span class="comment"># 不过这个数据集可能就会比较大</span></span><br><span class="line">rdbcompression yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否校验rdb文件</span></span><br><span class="line">rdbchecksum yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置 dump 的文件位置</span></span><br><span class="line">dbfilename dump.rdb</span><br><span class="line"></span><br><span class="line"><span class="comment"># 工作目录</span></span><br><span class="line"><span class="comment"># 例如上面的 dbfilename 只指定了文件名，</span></span><br><span class="line"><span class="comment"># 但是它会写入到这个目录下。这个配置项一定是个目录，而不能是文件名。</span></span><br><span class="line">dir ./</span><br><span class="line"></span><br><span class="line"><span class="comment">################################# 主从复制 #################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主从复制。使用 slaveof 来让一个 redis 实例成为另一个reids 实例的副本。</span></span><br><span class="line"><span class="comment"># 注意这个只需要在 slave 上配置。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># slaveof &lt;masterip&gt; &lt;masterport&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果 master 需要密码认证，就在这里设置</span></span><br><span class="line"><span class="comment"># masterauth &lt;master-password&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当一个 slave 与 master 失去联系，或者复制正在进行的时候，</span></span><br><span class="line"><span class="comment"># slave 可能会有两种表现：</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) 如果为 yes ，slave 仍然会应答客户端请求，但返回的数据可能是过时，</span></span><br><span class="line"><span class="comment">#    或者数据可能是空的在第一次同步的时候</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2) 如果为 no ，在你执行除了 info he salveof 之外的其他命令时，</span></span><br><span class="line"><span class="comment">#    slave 都将返回一个 "SYNC with master in progress" 的错误，</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">slave-serve-stale-data yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># 你可以配置一个 slave 实体是否接受写入操作。</span></span><br><span class="line"><span class="comment"># 通过写入操作来存储一些短暂的数据对于一个 slave 实例来说可能是有用的，</span></span><br><span class="line"><span class="comment"># 因为相对从 master 重新同步数而言，据数据写入到 slave 会更容易被删除。</span></span><br><span class="line"><span class="comment"># 但是如果客户端因为一个错误的配置写入，也可能会导致一些问题。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 从 redis 2.6 版起，默认 slaves 都是只读的。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> read only slaves are not designed to be exposed to untrusted clients</span></span><br><span class="line"><span class="comment"># on the internet. It's just a protection layer against misuse of the instance.</span></span><br><span class="line"><span class="comment"># Still a read only slave exports by default all the administrative commands</span></span><br><span class="line"><span class="comment"># such as CONFIG, DEBUG, and so forth. To a limited extent you can improve</span></span><br><span class="line"><span class="comment"># security of read only slaves using 'rename-command' to shadow all the</span></span><br><span class="line"><span class="comment"># administrative / dangerous commands.</span></span><br><span class="line"><span class="comment"># 注意：只读的 slaves 没有被设计成在 internet 上暴露给不受信任的客户端。</span></span><br><span class="line"><span class="comment"># 它仅仅是一个针对误用实例的一个保护层。</span></span><br><span class="line">slave-read-only yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># Slaves 在一个预定义的时间间隔内发送 ping 命令到 server 。</span></span><br><span class="line"><span class="comment"># 你可以改变这个时间间隔。默认为 10 秒。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-ping-slave-period 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The following option sets the replication timeout for:</span></span><br><span class="line"><span class="comment"># 设置主从复制过期时间</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) Bulk transfer I/O during SYNC, from the point of view of slave.</span></span><br><span class="line"><span class="comment"># 2) Master timeout from the point of view of slaves (data, pings).</span></span><br><span class="line"><span class="comment"># 3) Slave timeout from the point of view of masters (REPLCONF ACK pings).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is important to make sure that this value is greater than the value</span></span><br><span class="line"><span class="comment"># specified for repl-ping-slave-period otherwise a timeout will be detected</span></span><br><span class="line"><span class="comment"># every time there is low traffic between the master and the slave.</span></span><br><span class="line"><span class="comment"># 这个值一定要比 repl-ping-slave-period 大</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-timeout 60</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Disable TCP_NODELAY on the slave socket after SYNC?</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you select "yes" Redis will use a smaller number of TCP packets and</span></span><br><span class="line"><span class="comment"># less bandwidth to send data to slaves. But this can add a delay for</span></span><br><span class="line"><span class="comment"># the data to appear on the slave side, up to 40 milliseconds with</span></span><br><span class="line"><span class="comment"># Linux kernels using a default configuration.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you select "no" the delay for data to appear on the slave side will</span></span><br><span class="line"><span class="comment"># be reduced but more bandwidth will be used for replication.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default we optimize for low latency, but in very high traffic conditions</span></span><br><span class="line"><span class="comment"># or when the master and slaves are many hops away, turning this to "yes" may</span></span><br><span class="line"><span class="comment"># be a good idea.</span></span><br><span class="line">repl-disable-tcp-nodelay no</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置主从复制容量大小。这个 backlog 是一个用来在 slaves 被断开连接时</span></span><br><span class="line"><span class="comment"># 存放 slave 数据的 buffer，所以当一个 slave 想要重新连接，通常不希望全部重新同步，</span></span><br><span class="line"><span class="comment"># 只是部分同步就够了，仅仅传递 slave 在断开连接时丢失的这部分数据。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The biggest the replication backlog, the longer the time the slave can be</span></span><br><span class="line"><span class="comment"># disconnected and later be able to perform a partial resynchronization.</span></span><br><span class="line"><span class="comment"># 这个值越大，salve 可以断开连接的时间就越长。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The backlog is only allocated once there is at least a slave connected.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-backlog-size 1mb</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># After a master has no longer connected slaves for some time, the backlog</span></span><br><span class="line"><span class="comment"># will be freed. The following option configures the amount of seconds that</span></span><br><span class="line"><span class="comment"># need to elapse, starting from the time the last slave disconnected, for</span></span><br><span class="line"><span class="comment"># the backlog buffer to be freed.</span></span><br><span class="line"><span class="comment"># 在某些时候，master 不再连接 slaves，backlog 将被释放。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A value of 0 means to never release the backlog.</span></span><br><span class="line"><span class="comment"># 如果设置为 0 ，意味着绝不释放 backlog 。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># repl-backlog-ttl 3600</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 当 master 不能正常工作的时候，Redis Sentinel 会从 slaves 中选出一个新的 master，</span></span><br><span class="line"><span class="comment"># 这个值越小，就越会被优先选中，但是如果是 0 ， 那是意味着这个 slave 不可能被选中。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 默认优先级为 100。</span></span><br><span class="line">slave-priority 100</span><br><span class="line"></span><br><span class="line"><span class="comment"># It is possible for a master to stop accepting writes if there are less than</span></span><br><span class="line"><span class="comment"># N slaves connected, having a lag less or equal than M seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The N slaves need to be in "online" state.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The lag in seconds, that must be &lt;= the specified value, is calculated from</span></span><br><span class="line"><span class="comment"># the last ping received from the slave, that is usually sent every second.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This option does not GUARANTEES that N replicas will accept the write, but</span></span><br><span class="line"><span class="comment"># will limit the window of exposure for lost writes in case not enough slaves</span></span><br><span class="line"><span class="comment"># are available, to the specified number of seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For example to require at least 3 slaves with a lag &lt;= 10 seconds use:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># min-slaves-to-write 3</span></span><br><span class="line"><span class="comment"># min-slaves-max-lag 10</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Setting one or the other to 0 disables the feature.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default min-slaves-to-write is set to 0 (feature disabled) and</span></span><br><span class="line"><span class="comment"># min-slaves-max-lag is set to 10.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## 安全 ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Require clients to issue AUTH &lt;PASSWORD&gt; before processing any other</span></span><br><span class="line"><span class="comment"># commands.  This might be useful in environments in which you do not trust</span></span><br><span class="line"><span class="comment"># others with access to the host running redis-server.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This should stay commented out for backward compatibility and because most</span></span><br><span class="line"><span class="comment"># people do not need auth (e.g. they run their own servers).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Warning: since Redis is pretty fast an outside user can try up to</span></span><br><span class="line"><span class="comment"># 150k passwords per second against a good box. This means that you should</span></span><br><span class="line"><span class="comment"># use a very strong password otherwise it will be very easy to break.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 设置认证密码</span></span><br><span class="line"><span class="comment"># requirepass foobared</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Command renaming.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is possible to change the name of dangerous commands in a shared</span></span><br><span class="line"><span class="comment"># environment. For instance the CONFIG command may be renamed into something</span></span><br><span class="line"><span class="comment"># hard to guess so that it will still be available for internal-use tools</span></span><br><span class="line"><span class="comment"># but not available for general clients.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Example:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is also possible to completely kill a command by renaming it into</span></span><br><span class="line"><span class="comment"># an empty string:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># rename-command CONFIG ""</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please note that changing the name of commands that are logged into the</span></span><br><span class="line"><span class="comment"># AOF file or transmitted to slaves may cause problems.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################### 限制 ####################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the max number of connected clients at the same time. By default</span></span><br><span class="line"><span class="comment"># this limit is set to 10000 clients, however if the Redis server is not</span></span><br><span class="line"><span class="comment"># able to configure the process file limit to allow for the specified limit</span></span><br><span class="line"><span class="comment"># the max number of allowed clients is set to the current file limit</span></span><br><span class="line"><span class="comment"># minus 32 (as Redis reserves a few file descriptors for internal uses).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 一旦达到最大限制，redis 将关闭所有的新连接</span></span><br><span class="line"><span class="comment"># 并发送一个‘max number of clients reached’的错误。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxclients 10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果你设置了这个值，当缓存的数据容量达到这个值， redis 将根据你选择的</span></span><br><span class="line"><span class="comment"># eviction 策略来移除一些 keys。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 如果 redis 不能根据策略移除 keys ，或者是策略被设置为 ‘noeviction’，</span></span><br><span class="line"><span class="comment"># redis 将开始响应错误给命令，如 set，lpush 等等，</span></span><br><span class="line"><span class="comment"># 并继续响应只读的命令，如 get</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This option is usually useful when using Redis as an LRU cache, or to set</span></span><br><span class="line"><span class="comment"># a hard memory limit for an instance (using the 'noeviction' policy).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># WARNING: If you have slaves attached to an instance with maxmemory on,</span></span><br><span class="line"><span class="comment"># the size of the output buffers needed to feed the slaves are subtracted</span></span><br><span class="line"><span class="comment"># from the used memory count, so that network problems / resyncs will</span></span><br><span class="line"><span class="comment"># not trigger a loop where keys are evicted, and in turn the output</span></span><br><span class="line"><span class="comment"># buffer of slaves is full with DELs of keys evicted triggering the deletion</span></span><br><span class="line"><span class="comment"># of more keys, and so forth until the database is completely emptied.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In short... if you have slaves attached it is suggested that you set a lower</span></span><br><span class="line"><span class="comment"># limit for maxmemory so that there is some free RAM on the system for slave</span></span><br><span class="line"><span class="comment"># output buffers (but this is not needed if the policy is 'noeviction').</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 最大使用内存</span></span><br><span class="line"><span class="comment"># maxmemory &lt;bytes&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大内存策略，你有 5 个选择。</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># volatile-lru -&gt; remove the key with an expire set using an LRU algorithm</span></span><br><span class="line"><span class="comment"># volatile-lru -&gt; 使用 LRU 算法移除包含过期设置的 key 。</span></span><br><span class="line"><span class="comment"># allkeys-lru -&gt; remove any key accordingly to the LRU algorithm</span></span><br><span class="line"><span class="comment"># allkeys-lru -&gt; 根据 LRU 算法移除所有的 key 。</span></span><br><span class="line"><span class="comment"># volatile-random -&gt; remove a random key with an expire set</span></span><br><span class="line"><span class="comment"># allkeys-random -&gt; remove a random key, any key</span></span><br><span class="line"><span class="comment"># volatile-ttl -&gt; remove the key with the nearest expire time (minor TTL)</span></span><br><span class="line"><span class="comment"># noeviction -&gt; don't expire at all, just return an error on write operations</span></span><br><span class="line"><span class="comment"># noeviction -&gt; 不让任何 key 过期，只是给写入操作返回一个错误</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># <span class="doctag">Note:</span> with any of the above policies, Redis will return an error on write</span></span><br><span class="line"><span class="comment">#       operations, when there are not suitable keys for eviction.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#       At the date of writing this commands are: set setnx setex append</span></span><br><span class="line"><span class="comment">#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd</span></span><br><span class="line"><span class="comment">#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby</span></span><br><span class="line"><span class="comment">#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby</span></span><br><span class="line"><span class="comment">#       getset mset msetnx exec sort</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxmemory-policy noeviction</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># LRU and minimal TTL algorithms are not precise algorithms but approximated</span></span><br><span class="line"><span class="comment"># algorithms (in order to save memory), so you can tune it for speed or</span></span><br><span class="line"><span class="comment"># accuracy. For default Redis will check five keys and pick the one that was</span></span><br><span class="line"><span class="comment"># used less recently, you can change the sample size using the following</span></span><br><span class="line"><span class="comment"># configuration directive.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default of 5 produces good enough results. 10 Approximates very closely</span></span><br><span class="line"><span class="comment"># true LRU but costs a bit more CPU. 3 is very fast but not very accurate.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># maxmemory-samples 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################## APPEND ONLY MODE ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># By default Redis asynchronously dumps the dataset on disk. This mode is</span></span><br><span class="line"><span class="comment"># good enough in many applications, but an issue with the Redis process or</span></span><br><span class="line"><span class="comment"># a power outage may result into a few minutes of writes lost (depending on</span></span><br><span class="line"><span class="comment"># the configured save points).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The Append Only File is an alternative persistence mode that provides</span></span><br><span class="line"><span class="comment"># much better durability. For instance using the default data fsync policy</span></span><br><span class="line"><span class="comment"># (see later in the config file) Redis can lose just one second of writes in a</span></span><br><span class="line"><span class="comment"># dramatic event like a server power outage, or a single write if something</span></span><br><span class="line"><span class="comment"># wrong with the Redis process itself happens, but the operating system is</span></span><br><span class="line"><span class="comment"># still running correctly.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># AOF and RDB persistence can be enabled at the same time without problems.</span></span><br><span class="line"><span class="comment"># If the AOF is enabled on startup Redis will load the AOF, that is the file</span></span><br><span class="line"><span class="comment"># with the better durability guarantees.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Please check http://redis.io/topics/persistence for more information.</span></span><br><span class="line"></span><br><span class="line">appendonly no</span><br><span class="line"></span><br><span class="line"><span class="comment"># The name of the append only file (default: "appendonly.aof")</span></span><br><span class="line"></span><br><span class="line">appendfilename <span class="string">"appendonly.aof"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The fsync() call tells the Operating System to actually write data on disk</span></span><br><span class="line"><span class="comment"># instead to wait for more data in the output buffer. Some OS will really flush</span></span><br><span class="line"><span class="comment"># data on disk, some other OS will just try to do it ASAP.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Redis supports three different modes:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># no: don't fsync, just let the OS flush the data when it wants. Faster.</span></span><br><span class="line"><span class="comment"># always: fsync after every write to the append only log . Slow, Safest.</span></span><br><span class="line"><span class="comment"># everysec: fsync only one time every second. Compromise.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is "everysec", as that's usually the right compromise between</span></span><br><span class="line"><span class="comment"># speed and data safety. It's up to you to understand if you can relax this to</span></span><br><span class="line"><span class="comment"># "no" that will let the operating system flush the output buffer when</span></span><br><span class="line"><span class="comment"># it wants, for better performances (but if you can live with the idea of</span></span><br><span class="line"><span class="comment"># some data loss consider the default persistence mode that's snapshotting),</span></span><br><span class="line"><span class="comment"># or on the contrary, use "always" that's very slow but a bit safer than</span></span><br><span class="line"><span class="comment"># everysec.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># More details please check the following article:</span></span><br><span class="line"><span class="comment"># http://antirez.com/post/redis-persistence-demystified.html</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If unsure, use "everysec".</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># appendfsync always</span></span><br><span class="line">appendfsync everysec</span><br><span class="line"><span class="comment"># appendfsync no</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When the AOF fsync policy is set to always or everysec, and a background</span></span><br><span class="line"><span class="comment"># saving process (a background save or AOF log background rewriting) is</span></span><br><span class="line"><span class="comment"># performing a lot of I/O against the disk, in some Linux configurations</span></span><br><span class="line"><span class="comment"># Redis may block too long on the fsync() call. Note that there is no fix for</span></span><br><span class="line"><span class="comment"># this currently, as even performing fsync in a different thread will block</span></span><br><span class="line"><span class="comment"># our synchronous write(2) call.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># In order to mitigate this problem it's possible to use the following option</span></span><br><span class="line"><span class="comment"># that will prevent fsync() from being called in the main process while a</span></span><br><span class="line"><span class="comment"># BGSAVE or BGREWRITEAOF is in progress.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This means that while another child is saving, the durability of Redis is</span></span><br><span class="line"><span class="comment"># the same as "appendfsync none". In practical terms, this means that it is</span></span><br><span class="line"><span class="comment"># possible to lose up to 30 seconds of log in the worst scenario (with the</span></span><br><span class="line"><span class="comment"># default Linux settings).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If you have latency problems turn this to "yes". Otherwise leave it as</span></span><br><span class="line"><span class="comment"># "no" that is the safest pick from the point of view of durability.</span></span><br><span class="line"></span><br><span class="line">no-appendfsync-on-rewrite no</span><br><span class="line"></span><br><span class="line"><span class="comment"># Automatic rewrite of the append only file.</span></span><br><span class="line"><span class="comment"># Redis is able to automatically rewrite the log file implicitly calling</span></span><br><span class="line"><span class="comment"># BGREWRITEAOF when the AOF log size grows by the specified percentage.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This is how it works: Redis remembers the size of the AOF file after the</span></span><br><span class="line"><span class="comment"># latest rewrite (if no rewrite has happened since the restart, the size of</span></span><br><span class="line"><span class="comment"># the AOF at startup is used).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># This base size is compared to the current size. If the current size is</span></span><br><span class="line"><span class="comment"># bigger than the specified percentage, the rewrite is triggered. Also</span></span><br><span class="line"><span class="comment"># you need to specify a minimal size for the AOF file to be rewritten, this</span></span><br><span class="line"><span class="comment"># is useful to avoid rewriting the AOF file even if the percentage increase</span></span><br><span class="line"><span class="comment"># is reached but it is still pretty small.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Specify a percentage of zero in order to disable the automatic AOF</span></span><br><span class="line"><span class="comment"># rewrite feature.</span></span><br><span class="line"></span><br><span class="line">auto-aof-rewrite-percentage 100</span><br><span class="line">auto-aof-rewrite-min-size 64mb</span><br><span class="line"></span><br><span class="line"><span class="comment">################################ LUA SCRIPTING  ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Max execution time of a Lua script in milliseconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If the maximum execution time is reached Redis will log that a script is</span></span><br><span class="line"><span class="comment"># still in execution after the maximum allowed time and will start to</span></span><br><span class="line"><span class="comment"># reply to queries with an error.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># When a long running script exceed the maximum execution time only the</span></span><br><span class="line"><span class="comment"># SCRIPT KILL and SHUTDOWN NOSAVE commands are available. The first can be</span></span><br><span class="line"><span class="comment"># used to stop a script that did not yet called write commands. The second</span></span><br><span class="line"><span class="comment"># is the only way to shut down the server in the case a write commands was</span></span><br><span class="line"><span class="comment"># already issue by the script but the user don't want to wait for the natural</span></span><br><span class="line"><span class="comment"># termination of the script.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Set it to 0 or a negative value for unlimited execution without warnings.</span></span><br><span class="line">lua-time-limit 5000</span><br><span class="line"></span><br><span class="line"><span class="comment">################################ REDIS 集群  ###############################</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 启用或停用集群</span></span><br><span class="line"><span class="comment"># cluster-enabled yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Every cluster node has a cluster configuration file. This file is not</span></span><br><span class="line"><span class="comment"># intended to be edited by hand. It is created and updated by Redis nodes.</span></span><br><span class="line"><span class="comment"># Every Redis Cluster node requires a different cluster configuration file.</span></span><br><span class="line"><span class="comment"># Make sure that instances running in the same system does not have</span></span><br><span class="line"><span class="comment"># overlapping cluster configuration file names.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-config-file nodes-6379.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster node timeout is the amount of milliseconds a node must be unreachable</span></span><br><span class="line"><span class="comment"># for it to be considered in failure state.</span></span><br><span class="line"><span class="comment"># Most other internal time limits are multiple of the node timeout.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-node-timeout 15000</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A slave of a failing master will avoid to start a failover if its data</span></span><br><span class="line"><span class="comment"># looks too old.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># There is no simple way for a slave to actually have a exact measure of</span></span><br><span class="line"><span class="comment"># its "data age", so the following two checks are performed:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 1) If there are multiple slaves able to failover, they exchange messages</span></span><br><span class="line"><span class="comment">#    in order to try to give an advantage to the slave with the best</span></span><br><span class="line"><span class="comment">#    replication offset (more data from the master processed).</span></span><br><span class="line"><span class="comment">#    Slaves will try to get their rank by offset, and apply to the start</span></span><br><span class="line"><span class="comment">#    of the failover a delay proportional to their rank.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># 2) Every single slave computes the time of the last interaction with</span></span><br><span class="line"><span class="comment">#    its master. This can be the last ping or command received (if the master</span></span><br><span class="line"><span class="comment">#    is still in the "connected" state), or the time that elapsed since the</span></span><br><span class="line"><span class="comment">#    disconnection with the master (if the replication link is currently down).</span></span><br><span class="line"><span class="comment">#    If the last interaction is too old, the slave will not try to failover</span></span><br><span class="line"><span class="comment">#    at all.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The point "2" can be tuned by user. Specifically a slave will not perform</span></span><br><span class="line"><span class="comment"># the failover if, since the last interaction with the master, the time</span></span><br><span class="line"><span class="comment"># elapsed is greater than:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#   (node-timeout * slave-validity-factor) + repl-ping-slave-period</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># So for example if node-timeout is 30 seconds, and the slave-validity-factor</span></span><br><span class="line"><span class="comment"># is 10, and assuming a default repl-ping-slave-period of 10 seconds, the</span></span><br><span class="line"><span class="comment"># slave will not try to failover if it was not able to talk with the master</span></span><br><span class="line"><span class="comment"># for longer than 310 seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A large slave-validity-factor may allow slaves with too old data to failover</span></span><br><span class="line"><span class="comment"># a master, while a too small value may prevent the cluster from being able to</span></span><br><span class="line"><span class="comment"># elect a slave at all.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For maximum availability, it is possible to set the slave-validity-factor</span></span><br><span class="line"><span class="comment"># to a value of 0, which means, that slaves will always try to failover the</span></span><br><span class="line"><span class="comment"># master regardless of the last time they interacted with the master.</span></span><br><span class="line"><span class="comment"># (However they'll always try to apply a delay proportional to their</span></span><br><span class="line"><span class="comment"># offset rank).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Zero is the only value able to guarantee that when all the partitions heal</span></span><br><span class="line"><span class="comment"># the cluster will always be able to continue.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-slave-validity-factor 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Cluster slaves are able to migrate to orphaned masters, that are masters</span></span><br><span class="line"><span class="comment"># that are left without working slaves. This improves the cluster ability</span></span><br><span class="line"><span class="comment"># to resist to failures as otherwise an orphaned master can't be failed over</span></span><br><span class="line"><span class="comment"># in case of failure if it has no working slaves.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Slaves migrate to orphaned masters only if there are still at least a</span></span><br><span class="line"><span class="comment"># given number of other working slaves for their old master. This number</span></span><br><span class="line"><span class="comment"># is the "migration barrier". A migration barrier of 1 means that a slave</span></span><br><span class="line"><span class="comment"># will migrate only if there is at least 1 other working slave for its master</span></span><br><span class="line"><span class="comment"># and so forth. It usually reflects the number of slaves you want for every</span></span><br><span class="line"><span class="comment"># master in your cluster.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Default is 1 (slaves migrate only if their masters remain with at least</span></span><br><span class="line"><span class="comment"># one slave). To disable migration just set it to a very large value.</span></span><br><span class="line"><span class="comment"># A value of 0 can be set but is useful only for debugging and dangerous</span></span><br><span class="line"><span class="comment"># in production.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># cluster-migration-barrier 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># In order to setup your cluster make sure to read the documentation</span></span><br><span class="line"><span class="comment"># available at http://redis.io web site.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">################################## SLOW LOG ###################################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The Redis Slow Log is a system to log queries that exceeded a specified</span></span><br><span class="line"><span class="comment"># execution time. The execution time does not include the I/O operations</span></span><br><span class="line"><span class="comment"># like talking with the client, sending the reply and so forth,</span></span><br><span class="line"><span class="comment"># but just the time needed to actually execute the command (this is the only</span></span><br><span class="line"><span class="comment"># stage of command execution where the thread is blocked and can not serve</span></span><br><span class="line"><span class="comment"># other requests in the meantime).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># You can configure the slow log with two parameters: one tells Redis</span></span><br><span class="line"><span class="comment"># what is the execution time, in microseconds, to exceed in order for the</span></span><br><span class="line"><span class="comment"># command to get logged, and the other parameter is the length of the</span></span><br><span class="line"><span class="comment"># slow log. When a new command is logged the oldest one is removed from the</span></span><br><span class="line"><span class="comment"># queue of logged commands.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The following time is expressed in microseconds, so 1000000 is equivalent</span></span><br><span class="line"><span class="comment"># to one second. Note that a negative number disables the slow log, while</span></span><br><span class="line"><span class="comment"># a value of zero forces the logging of every command.</span></span><br><span class="line">slowlog-log-slower-than 10000</span><br><span class="line"></span><br><span class="line"><span class="comment"># There is no limit to this length. Just be aware that it will consume memory.</span></span><br><span class="line"><span class="comment"># You can reclaim memory used by the slow log with SLOWLOG RESET.</span></span><br><span class="line">slowlog-max-len 128</span><br><span class="line"></span><br><span class="line"><span class="comment">############################# Event notification ##############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis can notify Pub/Sub clients about events happening in the key space.</span></span><br><span class="line"><span class="comment"># This feature is documented at http://redis.io/topics/keyspace-events</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># For instance if keyspace events notification is enabled, and a client</span></span><br><span class="line"><span class="comment"># performs a DEL operation on key "foo" stored in the Database 0, two</span></span><br><span class="line"><span class="comment"># messages will be published via Pub/Sub:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># PUBLISH __keyspace@0__:foo del</span></span><br><span class="line"><span class="comment"># PUBLISH __keyevent@0__:del foo</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># It is possible to select the events that Redis will notify among a set</span></span><br><span class="line"><span class="comment"># of classes. Every class is identified by a single character:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  K     Keyspace events, published with __keyspace@&lt;db&gt;__ prefix.</span></span><br><span class="line"><span class="comment">#  E     Keyevent events, published with __keyevent@&lt;db&gt;__ prefix.</span></span><br><span class="line"><span class="comment">#  g     Generic commands (non-type specific) like DEL, EXPIRE, RENAME, ...</span></span><br><span class="line"><span class="comment">#  $     String commands</span></span><br><span class="line"><span class="comment">#  l     List commands</span></span><br><span class="line"><span class="comment">#  s     Set commands</span></span><br><span class="line"><span class="comment">#  h     Hash commands</span></span><br><span class="line"><span class="comment">#  z     Sorted set commands</span></span><br><span class="line"><span class="comment">#  x     Expired events (events generated every time a key expires)</span></span><br><span class="line"><span class="comment">#  e     Evicted events (events generated when a key is evicted for maxmemory)</span></span><br><span class="line"><span class="comment">#  A     Alias for g$lshzxe, so that the "AKE" string means all the events.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  The "notify-keyspace-events" takes as argument a string that is composed</span></span><br><span class="line"><span class="comment">#  by zero or multiple characters. The empty string means that notifications</span></span><br><span class="line"><span class="comment">#  are disabled at all.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Example: to enable list and generic events, from the point of view of the</span></span><br><span class="line"><span class="comment">#           event name, use:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  notify-keyspace-events Elg</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  Example 2: to get the stream of the expired keys subscribing to channel</span></span><br><span class="line"><span class="comment">#             name __keyevent@0__:expired use:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  notify-keyspace-events Ex</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#  By default all notifications are disabled because most users don't need</span></span><br><span class="line"><span class="comment">#  this feature and the feature has some overhead. Note that if you don't</span></span><br><span class="line"><span class="comment">#  specify at least one of K or E, no events will be delivered.</span></span><br><span class="line">notify-keyspace-events <span class="string">""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">############################### ADVANCED CONFIG ###############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Hashes are encoded using a memory efficient data structure when they have a</span></span><br><span class="line"><span class="comment"># small number of entries, and the biggest entry does not exceed a given</span></span><br><span class="line"><span class="comment"># threshold. These thresholds can be configured using the following directives.</span></span><br><span class="line"><span class="built_in">hash</span>-max-ziplist-entries 512</span><br><span class="line"><span class="built_in">hash</span>-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Similarly to hashes, small lists are also encoded in a special way in order</span></span><br><span class="line"><span class="comment"># to save a lot of space. The special representation is only used when</span></span><br><span class="line"><span class="comment"># you are under the following limits:</span></span><br><span class="line">list-max-ziplist-entries 512</span><br><span class="line">list-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sets have a special encoding in just one case: when a set is composed</span></span><br><span class="line"><span class="comment"># of just strings that happens to be integers in radix 10 in the range</span></span><br><span class="line"><span class="comment"># of 64 bit signed integers.</span></span><br><span class="line"><span class="comment"># The following configuration setting sets the limit in the size of the</span></span><br><span class="line"><span class="comment"># set in order to use this special memory saving encoding.</span></span><br><span class="line"><span class="built_in">set</span>-max-intset-entries 512</span><br><span class="line"></span><br><span class="line"><span class="comment"># Similarly to hashes and lists, sorted sets are also specially encoded in</span></span><br><span class="line"><span class="comment"># order to save a lot of space. This encoding is only used when the length and</span></span><br><span class="line"><span class="comment"># elements of a sorted set are below the following limits:</span></span><br><span class="line">zset-max-ziplist-entries 128</span><br><span class="line">zset-max-ziplist-value 64</span><br><span class="line"></span><br><span class="line"><span class="comment"># HyperLogLog sparse representation bytes limit. The limit includes the</span></span><br><span class="line"><span class="comment"># 16 bytes header. When an HyperLogLog using the sparse representation crosses</span></span><br><span class="line"><span class="comment"># this limit, it is converted into the dense representation.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A value greater than 16000 is totally useless, since at that point the</span></span><br><span class="line"><span class="comment"># dense representation is more memory efficient.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The suggested value is ~ 3000 in order to have the benefits of</span></span><br><span class="line"><span class="comment"># the space efficient encoding without slowing down too much PFADD,</span></span><br><span class="line"><span class="comment"># which is O(N) with the sparse encoding. The value can be raised to</span></span><br><span class="line"><span class="comment"># ~ 10000 when CPU is not a concern, but space is, and the data set is</span></span><br><span class="line"><span class="comment"># composed of many HyperLogLogs with cardinality in the 0 - 15000 range.</span></span><br><span class="line">hll-sparse-max-bytes 3000</span><br><span class="line"></span><br><span class="line"><span class="comment"># Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in</span></span><br><span class="line"><span class="comment"># order to help rehashing the main Redis hash table (the one mapping top-level</span></span><br><span class="line"><span class="comment"># keys to values). The hash table implementation Redis uses (see dict.c)</span></span><br><span class="line"><span class="comment"># performs a lazy rehashing: the more operation you run into a hash table</span></span><br><span class="line"><span class="comment"># that is rehashing, the more rehashing "steps" are performed, so if the</span></span><br><span class="line"><span class="comment"># server is idle the rehashing is never complete and some more memory is used</span></span><br><span class="line"><span class="comment"># by the hash table.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The default is to use this millisecond 10 times every second in order to</span></span><br><span class="line"><span class="comment"># active rehashing the main dictionaries, freeing memory when possible.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># If unsure:</span></span><br><span class="line"><span class="comment"># use "activerehashing no" if you have hard latency requirements and it is</span></span><br><span class="line"><span class="comment"># not a good thing in your environment that Redis can reply form time to time</span></span><br><span class="line"><span class="comment"># to queries with 2 milliseconds delay.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># use "activerehashing yes" if you don't have such hard requirements but</span></span><br><span class="line"><span class="comment"># want to free memory asap when possible.</span></span><br><span class="line">activerehashing yes</span><br><span class="line"></span><br><span class="line"><span class="comment"># The client output buffer limits can be used to force disconnection of clients</span></span><br><span class="line"><span class="comment"># that are not reading data from the server fast enough for some reason (a</span></span><br><span class="line"><span class="comment"># common reason is that a Pub/Sub client can't consume messages as fast as the</span></span><br><span class="line"><span class="comment"># publisher can produce them).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The limit can be set differently for the three different classes of clients:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># normal -&gt; normal clients</span></span><br><span class="line"><span class="comment"># slave  -&gt; slave clients and MONITOR clients</span></span><br><span class="line"><span class="comment"># pubsub -&gt; clients subscribed to at least one pubsub channel or pattern</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The syntax of every client-output-buffer-limit directive is the following:</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># client-output-buffer-limit &lt;class&gt; &lt;hard limit&gt; &lt;soft limit&gt; &lt;soft seconds&gt;</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># A client is immediately disconnected once the hard limit is reached, or if</span></span><br><span class="line"><span class="comment"># the soft limit is reached and remains reached for the specified number of</span></span><br><span class="line"><span class="comment"># seconds (continuously).</span></span><br><span class="line"><span class="comment"># So for instance if the hard limit is 32 megabytes and the soft limit is</span></span><br><span class="line"><span class="comment"># 16 megabytes / 10 seconds, the client will get disconnected immediately</span></span><br><span class="line"><span class="comment"># if the size of the output buffers reach 32 megabytes, but will also get</span></span><br><span class="line"><span class="comment"># disconnected if the client reaches 16 megabytes and continuously overcomes</span></span><br><span class="line"><span class="comment"># the limit for 10 seconds.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default normal clients are not limited because they don't receive data</span></span><br><span class="line"><span class="comment"># without asking (in a push way), but just after a request, so only</span></span><br><span class="line"><span class="comment"># asynchronous clients may create a scenario where data is requested faster</span></span><br><span class="line"><span class="comment"># than it can read.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Instead there is a default limit for pubsub and slave clients, since</span></span><br><span class="line"><span class="comment"># subscribers and slaves receive data in a push fashion.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Both the hard or the soft limit can be disabled by setting them to zero.</span></span><br><span class="line">client-output-buffer-limit normal 0 0 0</span><br><span class="line">client-output-buffer-limit slave 256mb 64mb 60</span><br><span class="line">client-output-buffer-limit pubsub 32mb 8mb 60</span><br><span class="line"></span><br><span class="line"><span class="comment"># Redis calls an internal function to perform many background tasks, like</span></span><br><span class="line"><span class="comment"># closing connections of clients in timeout, purging expired keys that are</span></span><br><span class="line"><span class="comment"># never requested, and so forth.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Not all tasks are performed with the same frequency, but Redis checks for</span></span><br><span class="line"><span class="comment"># tasks to perform accordingly to the specified "hz" value.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># By default "hz" is set to 10. Raising the value will use more CPU when</span></span><br><span class="line"><span class="comment"># Redis is idle, but at the same time will make Redis more responsive when</span></span><br><span class="line"><span class="comment"># there are many keys expiring at the same time, and timeouts may be</span></span><br><span class="line"><span class="comment"># handled with more precision.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># The range is between 1 and 500, however a value over 100 is usually not</span></span><br><span class="line"><span class="comment"># a good idea. Most users should use the default of 10 and raise this up to</span></span><br><span class="line"><span class="comment"># 100 only in environments where very low latency is required.</span></span><br><span class="line">hz 10</span><br><span class="line"></span><br><span class="line"><span class="comment"># When a child rewrites the AOF file, if the following option is enabled</span></span><br><span class="line"><span class="comment"># the file will be fsync-ed every 32 MB of data generated. This is useful</span></span><br><span class="line"><span class="comment"># in order to commit the file to the disk more incrementally and avoid</span></span><br><span class="line"><span class="comment"># big latency spikes.</span></span><br><span class="line">aof-rewrite-incremental-fsync yes</span><br></pre></td></tr></table></figure>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">杨振宇</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://www.yangzhenyu.com.cn/11214/">https://www.yangzhenyu.com.cn/11214/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://www.yangzhenyu.com.cn">杨振宇'Blog</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/分布式/">分布式</a><a class="post-meta__tags" href="/tags/linux/">linux</a><a class="post-meta__tags" href="/tags/redis/">redis</a></div><div class="post-qr-code"><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/yttrium2016/img/master/20190222151401.png"><div class="post-qr-code__desc">支付宝打赏</div></div><div class="post-qr-code-item"><img class="post-qr-code__img" src="https://raw.githubusercontent.com/yttrium2016/img/master/20190222151504.png"><div class="post-qr-code__desc">微信打赏</div></div></div><div class="social-share pull-right"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script><nav id="pagination"><div class="prev-post pull-left"><a href="/41316/"><i class="fa fa-chevron-left">  </i><span>Redis基本指令操作</span></a></div><div class="next-post pull-right"><a href="/1/"><span>Linux搭建zookeeper环境</span><i class="fa fa-chevron-right"></i></a></div></nav><div id="gitalk-container"></div><script>var gitalk = new Gitalk({
  clientID: '34b21ee58acdcdea4814',
  clientSecret: 'edcdb38266a1aac9885209a7f34bad5c4ea06c0a',
  repo: 'yttrium2016.github.io',
  owner: 'yttrium2016',
  admin: 'yttrium2016',
  id: md5(decodeURI(location.pathname)),
  language: 'zh-CN'
})
gitalk.render('gitalk-container')</script></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2022 By 杨振宇</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="icp"><a href="https://beian.miit.gov.cn"><span>浙ICP备16002000号-3</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="/js/third-party/anime.min.js"></script><script src="/js/third-party/jquery.min.js"></script><script src="/js/third-party/jquery.fancybox.min.js"></script><script src="/js/third-party/velocity.min.js"></script><script src="/js/third-party/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.0"></script><script src="/js/fancybox.js?version=1.9.0"></script><script src="/js/sidebar.js?version=1.9.0"></script><script src="/js/copy.js?version=1.9.0"></script><script src="/js/fireworks.js?version=1.9.0"></script><script src="/js/transition.js?version=1.9.0"></script><script src="/js/scroll.js?version=1.9.0"></script><script src="/js/head.js?version=1.9.0"></script><script src="/js/search/local-search.js"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>